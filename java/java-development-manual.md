# Java 开发手册

## 代码
- 代码是否存在警告？
- 代码是否存在重复的开销？
- 代码是否存在空指针异常？
- 代码中局部内容是否尽量的少？
- 是否使用了适合业务场景的设计模式？
- 是否使用了适合业务场景的数据结构？
- 程序每个功能点是否存在不需要发送的 http 请求？
- 程序是否跑得足够快？分配的空间是否足够小？
- 程序在高并发下 Full GC 是否频繁？
- 数组如何设计才能最大程度的节约内存空间？<br>
二维或多维数组的结构设计不当会导致大量的空间浪费
- 对比两个对象是否为同一个对象时，是否尽量少的使用默认的 hashCode() 方法？<br>
默认的 hashCode() 方法会产生 native 调用的开销。
- equals() 内部实现是否足够简单？<br>
实现可以是业务上最快能区分对象的方式。
- 在知道 List 长度范围的情况下，是否在实例化 ArrayList 的时候带上长度？<br>
如果写入的数据较多，可能发生多次扩容，这样就会有多余的垃圾空间产生。

## I/O
- 程序是否存在句柄泄露？

## 一、编程规约
### （一）命名风格
8. 【强制】POJO 类中的任何布尔类型的变量，都不要加 is 前缀，否则部分框架解析会引起序列化错误。
9. 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。
10. 【强制】避免在子父类的成员变量之间、或者不同代码块的局部变量之间采用完全相同的命名，使可读性降低。
17. 【参考】枚举类名带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。

### （二）常量定义
3. 【推荐】不要使用一个常量类维护所有常量，要按常量功能进行归类，分开维护。

### （三）代码格式
5. 【强制】采用 4 个空格缩进，禁止使用 tab 字符。
7. 【强制】在进行类型强制转换时，右括号与强制转换值之间不需要任何空格隔开。
11. 【推荐】单个方法的总行数不超过 80 行。

### （四）OOP 规约
3. 【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。
8. 【强制】任何货币金额，均以最小货币单位且整型类型来进行存储。
9. 【强制】浮点数之间的等值判断，基本数据类型不能用==来比较，包装数据类型不能用 equals
来判断。
11. 【强制】禁止使用构造方法 BigDecimal(double)的方式把 double 值转化为 BigDecimal 对象。
12. 关于基本数据类型与包装数据类型的使用标准如下：
1） 【强制】所有的 POJO 类属性必须使用包装数据类型。
2） 【强制】RPC 方法的返回值和参数必须使用包装数据类型。
3） 【推荐】所有的局部变量使用基本数据类型
16. 【强制】POJO 类必须写 toString 方法。使用 IDE 中的工具：source> generate toString 时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。

### （五）日期时间
4. 【强制】不允许在程序任何地方中使用：1）java.sql.Date 2）java.sql.Time 3）java.sql.Timestamp。

### （六）集合处理
3. 【强制】在使用 java.util.stream.Collectors 类的 toMap()方法转为 Map 集合时，一定要使用含有参数类型为 BinaryOperator，参数名为 mergeFunction 的方法，否则当出现相同 key 值时会抛出 IllegalStateException 异常。
7. 【强制】Collections 类返回的对象，如：emptyList()/singletonList()等都是 immutable list，不可对其进行添加或者删除元素的操作。
18. 【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。

### （七）并发处理
4. 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。
8. 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。
9. 【强制】在使用阻塞等待获取锁的方式中，必须在 try 代码块之外，并且在加锁方法与 try 代码块之间没有任何可能抛出异常的方法调用，避免加锁成功后，在 finally 中无法解锁。
10. 【强制】在使用尝试机制来获取锁的方式中，进入业务代码块之前，必须先判断当前线程是否持有锁。锁的释放规则与锁的阻塞等待方式相同。
13. 【推荐】资金相关的金融敏感信息，使用悲观锁策略。
19. 【参考】ThreadLocal 对象使用 static 修饰，ThreadLocal 无法解决共享对象的更新问题。

### （八）控制语句
4. 【强制】三目运算符 condition? 表达式 1 : 表达式 2 中，高度注意表达式 1 和 2 在类型对齐时，可能抛出因自动拆箱导致的 NPE 异常。
5. 【强制】在高并发场景中，避免使用”等于”判断作为中断或退出的条件。

### （十）其它
2. 【强制】避免用 Apache Beanutils 进行属性的 copy。

## 二、异常日志
### （一）错误码
3. 【强制】全部正常，但不得不填充错误码时返回五个零：00000。
4. 【强制】错误码为字符串类型，共 5 位，分成两个部分：错误产生来源+四位数字编号。
11. 【参考】错误码的后三位编号与 HTTP 状态码没有任何关系。

### （二）异常处理
7. 【强制】不要在 finally 块中使用 return。
9. 【强制】在调用 RPC、二方包、或动态生成类的相关方法时，捕捉异常必须使用 Throwable 类来进行拦截。

### （三）日志规约
2. 【强制】所有日志文件至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。对于当天日志，以“应用名.log”来保存，保存在/home/admin/应用名/logs/</font>目录下，过往日志格式为: {logname}.log.{保存日期}，日期格式：yyyy-MM-dd。
4. 【强制】在日志输出时，字符串变量之间的拼接使用占位符的方式。
6. 【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。
9. 【强制】日志打印时禁止直接用 JSON 工具将对象转换成 String。

## 三、单元测试
1. 【强制】好的单元测试必须遵守 AIR 原则。
- A：Automatic（自动化）
- I：Independent（独立性）
- R：Repeatable（可重复）

2. 【强制】输出结果需要人工检查的测试不是一个好的单元测试。单元测试中不准使用 System.out 来进行人肉验证，必须使用 assert 来验证。
9. 【推荐】编写单元测试代码遵守 BCDE 原则，以保证被测试模块的交付质量。
- B：Border，边界值测试，包括循环边界、特殊取值、特殊时间点、数据顺序等。
- C：Correct，正确的输入，并得到预期的结果。
- D：Design，与设计文档相结合，来编写单元测试。
- E：Error，强制错误信息输入（如：非法数据、异常流程、业务允许外等），并得到预期的结果。

## 四、安全规约
3. 【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。
5. 【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。
6. 【强制】表单、AJAX 提交必须执行 CSRF 安全验证。
7. 【强制】URL 外部重定向传入的目标地址必须执行白名单过滤。
8. 【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放的机制，如数量限制、疲劳度控制、验证码校验，避免被滥刷而导致资损。

## 六、工程结构
### (一) 应用分层
3. 【参考】分层领域模型规约：
- DO（Data Object）：此对象与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。
- DTO（Data Transfer Object）：数据传输对象，Service 或 Manager 向外传输的对象。
- BO（Business Object）：业务对象，可以由 Service 层输出的封装业务逻辑的对象。
- Query：数据查询对象，各层接收上层的查询请求。注意超过 2 个参数的查询封装，禁止使用 Map 类
来传输。
- VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。

### (二) 二房库依赖
12. 【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：
- 精简可控原则。移除一切不必要的 API 和依赖，只包含 Service API、必要的领域模型对象、Utils 类、
常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用者去依赖具体版本号；无 log
具体实现，只依赖日志框架。
- 稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除
非用户主动升级版本，否则公共二方库的行为不应该发生变化。

### (三) 服务器
4. 【推荐】在线上生产环境，JVM 的 Xms 和 Xmx 设置一样大小的内存容量，避免在 GC 后调整堆大小带来的压力。
5. 【参考】服务器内部重定向必须使用 forward；外部重定向地址必须使用 URL Broker 生成，否则因线上采用 HTTPS 协议而导致浏览器提示“不安全“。此外，还会带来 URL 维护不一致的问题。

## 参考
[阿里巴巴Java开发手册（泰山版）.pdf](https://github.com/alibaba/p3c)  
